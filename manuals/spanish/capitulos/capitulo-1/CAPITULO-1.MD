# Cap√≠tulo 1: Conceptos Fundamentales
## ¬øQu√© es un Canister?
Hay una palabra que necesitas dominar absolutamente durante esta semana. ¬øEst√°s listo? Es... ü•Å... **CANISTER**!

El Internet Computer es una plataforma que aloja una gran cantidad de aplicaciones, todas las cuales se ejecutan sin problemas en contenedores especiales llamados **canisters**.

- El Internet Computer se encarga de ejecutar de manera fluida y segura todos los canisters implementados en la plataforma en paralelo.
- Los desarrolladores construyen aplicaciones escribiendo c√≥digo fuente para esos canisters. Una aplicaci√≥n puede estar compuesta por uno o varios canisters dependiendo de la arquitectura.
- Los usuarios interact√∫an con las aplicaciones enviando mensajes a los canisters. Esto sucede cada vez que usas una aplicaci√≥n en el Internet Computer e interact√∫as con ella; algunos ejemplos de tales interacciones son:
    - Cuando publicas en una red social.
    - Cuando env√≠as un token a otra direcci√≥n.
    - Cuando compras o vendes un NFT.
    - Cuando lees contenido en un sitio web alojado en el Internet Computer.
    - ¬°Y muchos m√°s!

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/oc_message.png" height="600px" style="border: 1px solid black;"/> </p>
<p align="center"> OpenChat es una aplicaci√≥n de mensajer√≠a descentralizada construida en el Internet Computer. </p>

## WebAssembly
Antes de pasar a Motoko, en realidad necesitamos explicar otro t√©rmino: **WebAssembly**.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/canister_overview.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Vista general de un canister.</p>

Si profundizamos en un canister, est√° compuesto por:
- Un **m√≥dulo WebAssembly** que es un fragmento de c√≥digo compilado a partir de lenguajes como Rust o Motoko. Este es el c√≥digo que se instala en el canister y que finalmente se ejecuta.
- Una **memoria WebAssembly** - tambi√©n llamada p√°ginas de memoria. Aqu√≠ es donde se almacena el estado del canister y se almacenan archivos (fotos, videos, tokens...). El c√≥digo que se ejecuta en el m√≥dulo WebAssembly modificar√° la memoria.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/webassembly.png" width="600px" style="border: 2px solid black;"> </p>

<p align="center"> ¬øQu√© es <b>WebAssembly</b>? </p>
WebAssembly es un formato binario de bajo nivel para ejecutar c√≥digo en m√∫ltiples entornos (navegadores, plataformas en la nube, dispositivos inteligentes, m√°quinas virtuales...). Los principales beneficios de usar WebAssembly son:

- **WebAssembly** admite c√≥digo escrito en varios lenguajes (C, C++, Rust, Motoko), lo que lo convierte en una soluci√≥n vers√°til para los desarrolladores.
- El c√≥digo de **WebAssembly** es portable y puede ejecutarse en casi cualquier dispositivo. ¬°Lo escribes una vez y lo ejecutas en cualquier lugar!
<p align="center"> <img src="../../../capitulos/capitulo-1/assets/webassembly_stack.png" width="500px" style="border: 1px solid black;"/> </p>
<p align="center"> Escribe una vez, implementa en cualquier plataforma. </p>

- **WebAssembly** es r√°pido. Es un lenguaje muy cercano al lenguaje de m√°quina y ha sido optimizado para la velocidad y el rendimiento. ¬°Puedes usarlo para crear aplicaciones complejas e intensivas (juegos, simulaciones, gr√°ficos)!
- **WebAssembly** proporciona un entorno de ejecuci√≥n seguro, colocando el c√≥digo en un √°rea especial llamada sandbox. El sandbox asegura que el programa solo pueda hacer cosas y acceder a los recursos a los que se le ha otorgado acceso y no permite que acceda a informaci√≥n confidencial. Esto es muy √∫til cuando se intenta escribir c√≥digo seguro o para que los usuarios se aseguren de que no ser√°n da√±ados por el c√≥digo que se ejecuta en su m√°quina.

El √∫nico problema con **WebAssembly** es que es un lenguaje de bajo nivel y proporciona muy poca abstracci√≥n, lo que dificulta su uso para escribir aplicaciones complejas como dApps (aplicaciones descentralizadas).

## El Lenguaje Motoko
<p align="center"> <img src="../../../capitulos/capitulo-1/assets/motoko_banner.png" width="600px" style="border: 1px solid black;"/> </p>

Es por eso que la [Fundaci√≥n DFINITY](https://dfinity.org/) ha introducido un nuevo lenguaje llamado **Motoko**, que es un lenguaje de programaci√≥n espec√≠ficamente dise√±ado para crear dApps en el Internet Computer. Dado que el c√≥digo de Motoko se puede compilar directamente en **WebAssembly**, es un lenguaje incre√≠ble para construir en el Internet Computer. Motoko es un lenguaje de alto nivel y f√°cil de usar. Escribes en Motoko y luego se compila en WebAssembly.

<p align="center"> <img src="../../../capitulos/capitulo-1/assets/motoko_to_wasm.png" width="600px" style="border: 1px solid black;"/> </p>
<p align="center"> En Motoko escribes el c√≥digo, en WebAssembly se ejecuta.</p>

> Vale la pena se√±alar que WebAssembly fue co-dise√±ado por [Andreas Rossberg](https://github.com/rossberg), quien se uni√≥ a la Fundaci√≥n DFINITY a principios de 2017 para trabajar en su entorno de ejecuci√≥n de contratos inteligentes de canister y tambi√©n es el dise√±ador original del lenguaje Motoko. El est√°ndar es mantenido por el [World Wide Web Consortium](https://www.w3.org/).

En el siguiente ejemplo, aqu√≠ hay una funci√≥n `factorial` ilustrada en **Motoko** y **WebAssembly**.
¬°No te preocupes si no entiendes nada, es normal!

<table align="center">
  <tr>
    <th> Motoko </th>
    <th>WebAssembly</th>
  </tr>
  <tr>
    <td> <pre> func factorial(n : Nat) : Nat { if (n == 0) { return 1; } else { return n * factorial(n - 1); } } </pre> </td>
    <td> <pre> (func $factorial (param $n i32) (result i32) (if (result i32) (i32.eqz (get_local $n)) (i32.const 1) (i32.mul (get_local $n) (call $factorial (i32.sub (get_local $n) (i32.const 1)))))) </pre> </td>

<td><pre>
20 00
42 00
51
04 7e
42 01
05
20 00
20 00
42 01
7d
10 00
7e
0b
</pre></td>
</tr>
</table><p align="center"> ¬øQu√© piensas? ¬øTe parece m√°s f√°cil escribir esta funci√≥n con <b>Motoko</b>? </p>

Un archivo de Motoko es un archivo con la extensi√≥n `.mo`.

<p align="center"> <img src="./assets/mo_extension.png" width="300px" style="border: 2px solid black;"> </p>

**Motoko** es un lenguaje de alto nivel como **JavaScript** o **Python**. En general, se considera m√°s f√°cil de aprender que un lenguaje de nivel inferior como **Rust** o **C**. 

---
<i> Motoko tiene una mascota genial que ha sido intensamente utilizada y modificada en la comunidad, ¬°para todo tipo de prop√≥sitos! 
As√≠ que no solo podr√°s construir aplicaciones descentralizadas de vanguardia con Motoko, sino que tambi√©n tendr√°s el logo m√°s genial del juego. ¬øNo nos crees? Solo mira el [mercado de Motoko NFT](https://entrepot.app/marketplace/motoko) y compru√©balo t√∫ mismo. </i>

## El modelo de actor.
Si abres un archivo de Motoko, hay una alta probabilidad de que la primera palabra que leer√°s sea `actor`:
```
actor {

    /// CODE

};
````
Un **actor** es c√≥mo se representa y abstrae un canister en **Motoko**. Este t√©rmino proviene del [modelo de actor](https://es.wikipedia.org/wiki/Modelo_de_actor) que es una forma de escribir programas de computadora que pueden manejar muchas tareas al mismo tiempo. Lo hace tratando a los **actores** como los bloques de construcci√≥n b√°sicos de un programa. <br/>
Un actor es un peque√±o programa de computadora que puede recibir mensajes, hacer alg√∫n trabajo y luego enviar mensajes a otros actores. Los actores tambi√©n pueden crear nuevos actores y controlarlos. Todos los actores se comunican entre s√≠ enviando mensajes. Dado que toda la interacci√≥n entre actores se realiza mediante el paso de mensajes, esto permite niveles muy altos de concurrencia y paralelismo, lo que lo hace muy adecuado para sistemas distribuidos. En ese sentido, ¬°el Internet Computer es una computadora distribuida donde cada programa es un canister!

Dado que los canisters se han implementado para seguir el modelo de actor, no te sorprender√° saber que los canisters:

- Tienen un estado privado (memoria) y pueden ejecutar c√°lculos.
- Reciben mensajes de usuarios u otros canisters.
- Pueden enviar mensajes a usuarios u otros canisters.
- Pueden crear otros canisters.


<p align="center"> <img src="./assets/actor_model.gif" width="800px" style="border: 2px solid black;"></p>
<p align="center">Un canister recibe un mensaje, lo ejecuta y posiblemente env√≠a otros mensajes a otros canisters (o incluso crear nuevos) en respuesta. </p>

Ahora consideremos el siguiente actor:
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```
Podemos ver que este actor tiene:
- Una variable llamada `message`, que se inicializa con un valor `Hello Motoko Bootcamp`.
- Dos funciones p√∫blicas:
    - `changeMessage` que actualiza el valor de `message` a lo que se proporcione como argumento.
    - `readMessage` que muestra el valor de `message` sin modificarlo.

La palabra clave `public` indica que ambas funciones pueden ser llamadas desde el exterior por usuarios u otros canisters. Las funciones `public` de un actor representan la [API](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones) del canister.
## Actualizar vs Consultar
¬øHas notado la palabra clave `query` en el ejemplo anterior?
<br/> Cuando un usuario llama a un canister, es importante distinguir dos tipos de llamadas:

### Llamadas de actualizaci√≥n
Las llamadas de actualizaci√≥n se utilizan cuando el usuario desea modificar el estado de un canister. Para garantizar la integridad del Internet Computer, estas llamadas deben procesarse a trav√©s del consenso y por todos los nodos, lo que resulta en un retraso de alrededor de 1-2 segundos. Se utilizar√≠a una llamada de actualizaci√≥n en las siguientes situaciones:
- Publicar en una red social, como [DSCVR](https://dscvr.one/).
- Enviar un mensaje en una aplicaci√≥n de mensajer√≠a, como [OpenChat](https://oc.app/).
- Dar me gusta o compartir un contenido en [Distrikt](https://az5sd-cqaaa-aaaae-aaarq-cai.ic0.app/).
- Comprar un NFT en [Entrepot](https://entrepot.app/).

<p align="center"> <img src="./assets/update_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

### Llamadas de consulta
Este tipo de llamada se utiliza cuando un usuario desea leer datos sin modificar el estado. Estas llamadas pueden ser respondidas por un solo nodo, lo que las hace muy r√°pidas (alrededor de 200ms). El inconveniente es que las llamadas de **consulta** son menos seguras ya que un nodo malintencionado podr√≠a proporcionar informaci√≥n falsa. Se utilizar√≠a una llamada de consulta en las siguientes situaciones:
- Leer un art√≠culo en [Nuance](https://nuance.xyz/).
- Verificar tu foto de perfil de usuario en 
- Cargar un video o una imagen en cualquier plataforma.

<p align="center"> <img src="./assets/query_call_gif.gif" width="800px" style="border: 2px solid black;"></p>

> Dado que una llamada de consulta omite el consenso y depende de un solo nodo, es menos segura que una llamada de actualizaci√≥n.


|  | Llamada de actualizaci√≥n | Llamada de consulta |
|-----------------|-----------------|-----------------|
Tiempo de respuesta | 2-5 segundos üê¢  | 200-400 ms ‚ö°Ô∏è  |
Consenso| S√≠ |¬†No |  
Leer | S√≠ | S√≠ |
Escribir| S√≠ | No |
Costo | Ciclos de costo | Gratis (por ahora)


Volviendo a nuestro actor anterior:
```motoko
actor {
    var message : Text = "Hello Motoko Bootcamp!";

    public func changeMessage(t : Text) : async () {
        message := t;
    };

    public query func readMessage() : async Text {
        return message;
    };
};
```

La palabra clave `query` nos indica que la funci√≥n `readMessage` solo se utiliza para leer informaci√≥n. Por otro lado, `changeMessage` puede actualizar el estado (no es necesario agregar la palabra clave `update` ya que se asume por defecto).

> Hemos implementado el actor anterior en el Internet Computer - y puedes acceder a <a href="https://a4gq6-oaaaa-aaaab-qaa4q-cai.raw.ic0.app/?id=rhjue-eaaaa-aaaaj-qazra-cai" target="_blank">su API</a>. Prueba la interfaz y comprueba la diferencia de velocidad entre `changeMessage` y `readMessage`. Divi√©rtete y deja un mensaje amable para el pr√≥ximo estudiante.

## Combustible en el Internet Computer: ciclos.
Para pagar los costos de computaci√≥n y almacenamiento, los canisters deben estar cargados con **ciclos**.
Cada canister tiene su propio saldo de **ciclos** - esto se puede pensar como la vida √∫til de la bater√≠a de un **canister**. 
Los **ciclos** se pueden obtener quemando **ICP**.

<p align="center"> <img src="./assets/cycles_burned.gif" width="600px" style="border: 2px solid black;"> </p>
<p align="center"> Al procesar un nuevo mensaje, se deducen ciclos del saldo del canister y se queman.</p>

A diferencia del **gas** en **Ethereum**, los **ciclos** en el **Internet Computer** no son pagados por el usuario. Esto significa que puedes interactuar con canisters y navegar por sitios web sin pagar nada. Esto se conoce como el modelo de **gas inverso** y es una gran mejora para la experiencia del usuario, ya que elimina la necesidad de crear billeteras, mantener tokens y pagar tarifas altas.

Los ciclos se miden en billones (T), lo que equivale a 1.000.000.000.000 o 10^12. Un bill√≥n de ciclos siempre cuesta 1 XDR, que es una moneda basada en las tasas de cambio del mercado que representa una canasta de principales monedas. A partir de ahora, 1 XDR equivale a $1,34. El precio de los ciclos no se ve afectado por el precio de los tokens ICP. En su lugar, la tasa de conversi√≥n de los tokens ICP a ciclos se ajusta constantemente mediante el seguimiento del precio de ICP.

Cada operaci√≥n realizada en la red tiene un costo asociado:
- Creaci√≥n de un canister.
- Ejecuci√≥n de un mensaje de actualizaci√≥n.
- Ejecuci√≥n de una llamada entre canisters.
- Almacenamiento de datos.
- Realizaci√≥n de una llamada HTTPS.
- C√°lculo de una firma ECDSA de umbral.

El costo de esas operaciones tambi√©n depende de la subred en la que se realizan y del **factor de replicaci√≥n** de esta subred. El factor de replicaci√≥n corresponde al n√∫mero de nodos en una subred, que puede variar de 13 a 40.
