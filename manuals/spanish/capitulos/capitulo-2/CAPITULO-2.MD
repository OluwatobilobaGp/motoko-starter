# Cap√≠tulo 2: Conceptos de programaci√≥n comunes.
## üì¶ Variables 
Una variable es un valor que tiene un nombre arbitrario, definido por una declaraci√≥n. <br/>
En Motoko, las variables se pueden declarar usando la palabra clave `let` o `var`, seguida del operador de asignaci√≥n `=`.

- Las variables declaradas con `let` son inmutables, lo que significa que su valor no puede cambiarse una vez que se asignan.```motoko
let n = 1;
```
- Las variables declaradas con `var` son mutables, lo que significa que su valor se puede reasignar a un nuevo valor en cualquier momento utilizando el operador de reasignaci√≥n `:=`.
```motoko
var n = 1;
n := 2;
```
La convenci√≥n de sintaxis es utilizar `lowerCamelCase` para los nombres de las variables y utilizar espacios alrededor del signo `=`. Adem√°s, una declaraci√≥n de variable termina con un punto y coma `;`. Cuando declares una variable, no olvides terminar la declaraci√≥n con `;`, de lo contrario Motoko mostrar√° un error.

Si intentamos el siguiente c√≥digo:
```motoko
let n = 1;
n := 2;
```

Se intenta reasignar un valor a una variable inmutable, por eso se producir√° un error. El mensaje de error espec√≠fico ser√° `type error [M0073], expected mutable assignment target`. Este mensaje indica que la variable que se est√° reasignando es inmutable y no se puede cambiar.

## üçé Tipos
El lenguaje **Motoko** hace mucho √©nfasis en los tipos y es m√°s estricto en su aplicaci√≥n en comparaci√≥n con otros lenguajes de prop√≥sito general como **JavaScript** o **Python**. Esta rigurosidad sirve a un prop√≥sito, ya que ayuda a prevenir errores e problemas.

**Motoko** tiene tipos est√°ticos, lo que significa que a cada variable se le asigna un tipo espec√≠fico, que se determina antes de que se ejecute el programa. El compilador verifica cada uso de la variable para evitar errores que puedan ocurrir durante la ejecuci√≥n del programa. <br/>

Para asignar un tipo a una variable, utilizamos el s√≠mbolo `:`, esto se llama **anotaci√≥n de tipo**.
```motoko
let age : Nat = 20;
let message : Text = "Of all the acts, the most complete is that of building";
let open : Bool = false;
```

Por lo general, se puede omitir la declaraci√≥n de tipo - el compilador de **Motoko** adivinar√° autom√°ticamente el tipo de la variable en funci√≥n del primer valor que proporciones, esto se llama **inferencia de tipo**.```
let age = 20;   // Will be assigned type Nat
```
> Durante la duraci√≥n del Bootcamp, se recomienda mantener todas las declaraciones de tipo para hacer las cosas m√°s claras, especialmente si eres nuevo en los lenguajes con tipos.

## üí¨ Comentarios.
Un comentario de una sola l√≠nea se escribe iniciando la l√≠nea con `//`.
```motoko
// Hello! It is recommended to use comments to make your code more readable.
```

Un comentario puede abarcar varias l√≠neas, en ese caso deber√°s agregar `//` en cada l√≠nea.
```motoko
//  Sometimes you'll have a lot to say
//  In those cases 
//  You can use more than one line
```
## ‚öôÔ∏è Funciones
Esta secci√≥n se centra √∫nicamente en las funciones que se definen dentro del cuerpo de un actor utilizando la sintaxis `actor {}`. Cualquier funci√≥n que est√© fuera de la sintaxis `actor {}` se cubrir√° en cap√≠tulos futuros.

### Un ejemplo sencillo
Para introducir las funciones, veamos un ejemplo: aqu√≠ hay un actor que es responsable de llevar un contador.
```motoko
actor Counter {
    var count : Nat = 0;

    public func setCount(n : Nat) : async Nat {
        count := n;
        return count;
    };

};
```

La palabra clave `func` se utiliza para declarar funciones, seguida del nombre que se le da a la funci√≥n, en este caso `increaseCount`. Al igual que con las variables, la convenci√≥n de sintaxis es utilizar `lowerCamelCase` para los nombres de las funciones.  <br/>

### Tipo de funci√≥n
Al definir una funci√≥n en Motoko, los argumentos y el tipo de retorno tipados se utilizan para determinar el tipo de la funci√≥n en su conjunto. Por ejemplo, la funci√≥n `setCount` tiene el siguiente tipo:
```motoko
setCount : (n : Nat) -> async Nat;
```
Para declarar una funci√≥n en Motoko, debes especificar los tipos de los argumentos y los valores de retorno. Los argumentos de la funci√≥n se encierran entre par√©ntesis `()`, y en este caso, la funci√≥n toma un argumento `n` de tipo `Nat`. Despu√©s de los argumentos de la funci√≥n, se especifica el tipo de retorno: `async Nat`.

> Es posible que te preguntes por qu√© el tipo de retorno de la funci√≥n `setCount` es `async Nat` en lugar de simplemente `Nat`. <br/> El t√©rmino `async` significa as√≠ncrono, lo que significa que, en el modelo de actores que discutimos anteriormente, los canisters o actores se comunican entre s√≠ de manera as√≠ncrona. Cuando un canister env√≠a una solicitud a otro (o cuando un usuario llama a una funci√≥n), habr√° un breve per√≠odo de espera antes de que el llamante reciba una respuesta. <br/> 
La programaci√≥n as√≠ncrona te permite ejecutar tu c√≥digo de forma no bloqueante. El tipo de retorno `async Nat` para la funci√≥n `setCount` indica que el llamante debe esperar unos momentos antes de recibir el valor de retorno. Eventualmente, la respuesta ser√° un valor de tipo `Nat`, pero con un retraso debido a la naturaleza as√≠ncrona de la comunicaci√≥n entre canisters. **Todas las funciones p√∫blicas declaradas en el cuerpo de un actor deben tener un tipo de retorno `async`**. 

### Cuerpo y retorno
- Las llaves `{}` se utilizan para el cuerpo de la funci√≥n. El cuerpo de la funci√≥n es un conjunto de instrucciones que se ejecutan cuando se llama a la funci√≥n.
En nuestro ejemplo, para `setCount` tenemos 2 instrucciones:
1. Asignar el valor de `count` al valor de `n`. 
2. Devolver el valor actual de `count`.

Motoko permite omitir el `return` al final del cuerpo de la funci√≥n, porque un bloque siempre se eval√∫a como su √∫ltima expresi√≥n. Lo que significa que podr√≠amos reescribir el c√≥digo de la siguiente manera y seguir√≠a siendo v√°lido:
```motoko
public func setCount(n : Nat) : async Nat {
    count := n;
    count;
};
```
### P√∫blico vs Privado
Hasta ahora solo hemos visto funciones `p√∫blicas`. Sin embargo, en Motoko tambi√©n puedes definir funciones `privadas`.
```motoko
private func add(n : Nat, m : Nat) : Nat {
    return (n + m)
};
```
La funci√≥n ahora est√° marcada como `privada`, lo que significa que solo puede ser utilizada por el actor y no puede ser llamada directamente por usuarios o canisters externos.

Por lo general, las funciones `privadas` se usan como ayudantes en otras funciones, que generalmente se definen como `p√∫blicas`. Por ejemplo, podr√≠amos escribir lo siguiente.
```motoko
actor {
    var count : Nat = 0;

    private func add(n : Nat, m : Nat) : Nat {
        return (n + m)
    };

    public func addCount(n : Nat) : async Nat {
        let newCount = add(count,n);
        count := newCount;
        return count;
    };
}
```

> Podemos eliminar la palabra clave `private`, una declaraci√≥n de funci√≥n se define como `privada` por defecto en Motoko a menos que se declare lo contrario (es decir, a menos que se declare `public`).

## üïπÔ∏è Control de flujo.
El control de flujo se refiere al orden en que se ejecuta un programa y el orden que sigue. Decide qu√© declaraciones, instrucciones o llamadas de funci√≥n se ejecutan y en qu√© orden, en funci√≥n de las condiciones o decisiones tomadas durante la ejecuci√≥n. <br/>

Discutimos tres constructos de control de flujo comunes en Motoko: expresiones `if else`, expresiones `loops` y expresiones `switch`.
### If/else
La instrucci√≥n `if` permite que el programa tome una decisi√≥n y ejecute un bloque de c√≥digo espec√≠fico solo si se cumple una condici√≥n espec√≠fica. La instrucci√≥n opcional `else` proporciona una alternativa si no se cumple la condici√≥n. 
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true
        } else {
            return false
        };
    };
```
En este caso, se probar√° la condici√≥n `n % 2` en tiempo de ejecuci√≥n y, seg√∫n el valor de `n`, devolver√° `true` o `false`.
En muchos casos, el bloque `else` se puede eliminar sin modificar el comportamiento del bloque de c√≥digo.
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true;
        };
        return false;
    };
```
En otros casos, se pueden agregar bloques `else if` para verificar condiciones adicionales.
```motoko
    func checkNumber(i : Int) : Text {
        if(n < 0) {
            return ("The number is negative.");
        } else if (n == 0) {
            return("The number is zero.");
        } else if (n < 10) {
            return("The number is one digits.");
        } else if (n < 100) {
            return("The number is two digits.");
        } else {
            return ("The number is three or more digits.");
        }
    };
```
Ten en cuenta que las sentencias `else if` se utilizan despu√©s de la sentencia `if` inicial para verificar condiciones adicionales, y solo se ejecutar√° el bloque de c√≥digo asociado a la primera condici√≥n que se eval√∫e como verdadera.

### Bucles
Los bucles permiten la ejecuci√≥n repetida de un bloque de c√≥digo hasta que se cumpla una condici√≥n espec√≠fica. Hay varios tipos de bucles, como los bucles `for` y los bucles `while`:
- Los bucles `for` en Motoko utilizan un iterador del tipo `Iter`. Profundizaremos en el tipo `Iter` en un cap√≠tulo posterior, pero para resumir, los objetos `Iter` facilitan el bucle a trav√©s de colecciones de datos.
```motoko
var count : Nat = 0;
for (x in Iter.range(0, 10)) {
    count += 1;
};
```
En este ejemplo, `Iter.range(0, 10)` itera a trav√©s de todos los n√∫meros naturales entre 0 y 10, inclusive de ambos l√≠mites.

Alternativamente, puedes usar bucles `while`, que se ejecutan mientras se cumpla la condici√≥n especificada.

```motoko
var count : Nat = 0;
while (count < 10) {
    count += 1;
};
```
En este caso, el bucle continuar√° ejecut√°ndose hasta que la variable `count` ya no sea menor que 10.
### Switch/case
La expresi√≥n `switch` en Motoko es un constructo de control de flujo que coincide con patrones basados en su entrada. Comienza con la palabra clave `switch`, seguida de la expresi√≥n de entrada encerrada entre par√©ntesis `()`, y un bloque de c√≥digo encerrado entre llaves `{}`.
```motoko
let x = 3;
switch(x) {
    //
};
```
Dentro del bloque de c√≥digo, se utiliza la palabra clave `case` para definir patrones y expresiones encerradas entre llaves `{}`. La entrada se compara con los patrones especificados en cada caso, y si se encuentra una coincidencia, se ejecuta la expresi√≥n dentro del bloque correspondiente de `case`.
```motoko
let x = 3;
switch(x) {
    case(0) {
        // This corresponds to the case x == 0
        return ("x is equal to 0");
    };
    case (1) {
        // This corresponds to the case x == 1
        return ("x is equal to 1");
    };
    case (2) {
        // This corresponds to the case x == 2
        return ("x is equal to 2");
    };
    case (_) {
        // This corresponds to all other cases
        return ("x is above 2");
    };
};
```
En Motoko, es obligatorio incluir una declaraci√≥n `case(_)` para cada valor de entrada posible en una expresi√≥n `switch`. Es por eso que a veces se utiliza el patr√≥n `case(_)` como un caso comod√≠n para manejar cualquier valor de entrada que no coincida con ninguno de los otros casos. El s√≠mbolo de gui√≥n bajo (`_`) es un comod√≠n que coincide con cualquier valor, por lo que el patr√≥n `case(_)` coincidir√° con cualquier valor de entrada.

La expresi√≥n `switch/case` se usa mejor con variantes.

```motoko
type Day = {
    #Monday;
    #Tuesday;
    #Wednesday;
    #Thursday;
    #Friday;
    #Saturday;
    #Sunday;
};
let day = #Monday;

switch(day) {
    case(#Monday){
        return ("Today is Monday");
    };
    case(#Tuesday){
        return ("Today is Tuesday");
    };
    case(#Wednesday){
        return ("Today is Wednesday");
    };
    case(#Thursday){
        return ("Today is Thursday");
    };
    case(#Friday){
        return ("Today is Friday");
    };
    case(#Saturday){
        return ("Today is Saturday");
    };
    case(#Sunday){
        return ("Enjoy your Sunday");
    };
};
```
En este ejemplo, definimos un tipo variante `Day`, declaramos una variable `day` con ese tipo y luego lo usamos como entrada en nuestra expresi√≥n `switch`. La expresi√≥n `switch` es un constructo de control de flujo poderoso que permite el patr√≥n de coincidencia, proporcionando una forma concisa y legible de manejar m√∫ltiples casos basados en el valor de entrada.
