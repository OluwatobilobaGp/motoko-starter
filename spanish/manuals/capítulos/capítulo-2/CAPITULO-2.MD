# Cap√≠tulo 2: Conceptos comunes de programaci√≥n.
## üì¶ Variables 
Una variable es un valor que tiene un nombre arbitrario, definido por una declaraci√≥n. <br/>
En Motoko, variables pueden ser declaradas usando la palabra clave `let` o `var`, seguido del operador de asignaci√≥n `=`

- Las variables declaradas con `let`son inmutables, lo que significa que su valor no puede ser cambiado una vez asignado. 
```motoko
let n = 1;
```
- Las variables declaradas con `var` son mutables, su valor puede ser reasignado a un valor nuevo en cualquier momento usando el operador de reasignaci√≥n `:=`.

```motoko
var n = 1;
n := 2;
```

La sintaxis convencional es usar `lowerCamelCase` para el nombre de variables y usar espacios alrededor del signo `=`. Adem√°s, la declaraci√≥n de una variable termina con un semicolon `;` Cuando declaramos una variable no olvides acabar la declaraci√≥n con `;` de otra manera Motoko se quejara.

Si probamos el siguiente c√≥digo:
```motoko
let n = 1;
n := 2;
```

En el c√≥digo anterior podemos ver que se produce un intento de reasignaci√≥n del valor de una variable inmutable - lo que resulta en un error. El mensaje de error en este caso ser√° `type error [M0073], expected mutable assignment target`. Este mensaje indica que la variable a la cual se le intent√≥ asignar un valor es inmutable por lo cual no puede ser modificada.
## üçé Tipos
El lenguaje  **Motoko** hace un gran √©nfasis en los tipos y es mas estricto respecto a estos comparado con otros lenguajes de prop√≥sito-general como **JavaScript** o **Python**. Esta dureza tiene su fin, ya que esto ayuda a prevenir errores y problemas. 

**Motoko** tiene tipos est√°ticos, lo que significa que cada variable es asignada con un tipo espec√≠fico, el cual es determinado antes de que el programa se ejecute. El compilador revisa cada uso de las variables para evitar errores que se puedan dar en la ejecuci√≥n. <br/>

Para asignar un tipo a una variable usamos el s√≠mbolo `:` , esto es llamado **type annotation**.
```motoko
let age : Nat = 20;
let message : Text = "Of all the acts, the most complete is that of building";
let open : Bool = false;
```

Por lo general puedes omitir la declaraci√≥n de tipo - el compilador de  **Motoko** autom√°ticamente adivinara el tipo de la variable bas√°ndose en el primer valor que le hayas otorgado, esto se llama **type inference**.
```
let age = 20;   // Will be assigned type Nat
```
> Para la duraci√≥n del Bootcamp  es recomendable declarar todas las variables para hacer las cosas m√°s claras, especialmente si eres nuevo en los lenguajes tipados.
## üí¨ Comentarios.
Un comentario de solo una l√≠nea es escrito empezando la l√≠nea con `//`.
```motoko
// Hello! It is recommended to use comments to make your code more readable.
```

Un comentario puede ser de l√≠neas m√∫ltiples, en ese caso necesitar√°s a√±adir `//` en cada l√≠nea.
```motoko
//  Sometimes you'll have a lot to say
//  In those cases 
//  You can use more than one line
```
## ‚öôÔ∏è Funciones
Esta secci√≥n se centra en funciones que son definidas en el cuerpo de un actor usando la sintaxis `actor {}`. Cualquier funci√≥n que est√° fuera de la sintaxis `actor {}` ser√° cubierta en futuros cap√≠tulos.
### Un ejemplo simple
Para introducir funciones - revisemos un ejemplo: aqu√≠ tenemos un actor que es responsable de llevar un registro de un counter. 
```motoko
actor Counter {
    var count : Nat = 0;

    public func setCount(n : Nat) : async Nat {
        count := n;
        return count;
    };

};
```

La palabra clave `func` es usada para declarar funciones, seguido por el nombre dado a la funci√≥n, en este caso `increaseCount`. Igual que con las variables As for variables, la sintaxis convencional es usar `lowerCamelCase` para el nombre de las funciones.  <br/>

### Function type
Cuando se define una funci√≥n en Motoko, los tipos de argumentos y el tipo de retorno son usados para determinar el tipo de la funci√≥n. Por ejemplo, la funci√≥n setCount tiene el siguiente tipo:
```motoko
setCount : (n : Nat) -> async Nat;
```
Para declarar una funci√≥n en Motoko, debes especificar los tipos de los argumentos y de los valores de retorno. Los argumentos de la funci√≥n se encuentran entre par√©ntesis `()`, y en este caso, la funci√≥n toma un argumento  `n` de tipo `Nat`. Despu√©s de los argumentos de la funci√≥n, el valor del retorno es especificado : `async Nat`.

> Te preguntar√°s porque el tipo de retorno de la funci√≥n `setCount` es `async Nat` en vez de simplemente`Nat`? <br/> El t√©rmino`async` significa as√≠ncrono,  lo que significa que en el **Actor model** que vimos anteriormente, canisters o actors se comunican entre s√≠ as√≠ncronamente. Cuando un canister env√≠a una solicitud a otro (o cuando usuarios llaman a una funci√≥n), habr√° un breve periodo de espera antes de que se reciba una respuesta
. <br/> 
Programaci√≥n as√≠ncrona te permite ejecutar tu c√≥digo en una manera non-blocking. El tipo de retorno`async Nat` para la funci√≥n `setCount` indica que el caller deber√° esperar por unos momentos antes de recibir el valor de retorno. Eventualmente, la respuesta ser√° tendr√° un tipo de valor `Nat`, pero con un retraso debido a la naturaleza as√≠ncrona de la comunicaci√≥n entre canisters. **Todas las funciones p√∫blicas declaradas en el cuerpo de un actor deben tener un tipo de retorno `async`**. 

### Cuerpo y retorno
- Las llaves `{}` son usadas para el cuerpo de la funci√≥n. El cuerpo de la funci√≥n es un conjunto de instrucciones que son ejecutadas cuando la funci√≥n es llamada.
En nuestro ejemplo, para `setCount` tenemos 2 instrucciones:
1. Asignar el valor de  `count` al valor de `n`. 
2. Retornar el valor de `count`.

Motoko permite omitir el `return` al final del cuerpo de la funci√≥n, ya que un bloque siempre es evaluado a su √∫ltima expresi√≥n. Lo que significa que podr√≠amos reescribir el c√≥digo de la siguiente forma y seguir√° siendo v√°lido:
```motoko
public func setCount(n : Nat) : async Nat {
    count := n;
    count;
};
```
### Public vs Private
Hasta ahora solo hemos visto las funciones `public`. Sin embargo, en Motoko tambi√©n puedes definir funciones `private`. 
```motoko
private func add(n : Nat, m : Nat) : Nat {
    return (n + m)
};
```
Ahora la funci√≥n est√° marcada como `private`, lo que significa que esta solo puede ser usada por el actor y no puede ser llamada directamente por usuarios o canisters externos.

Normalmente las funciones `private` son usadas como ayudantes de otras funciones, que generalmente son definidas como `public`. Por lo que podr√≠amos escribir el siguiente c√≥digo.

```motoko
actor {
    var count : Nat = 0;

    private func add(n : Nat, m : Nat) : Nat {
        return (n + m)
    };

    public func addCount(n : Nat) : async Nat {
        let newCount = add(count,n);
        count := newCount;
        return count;
    };
}
```

> Podemos remover la palabra clave `private` ,una funci√≥n en Motoko por defecto es declarada private a no ser que se especifique lo contrario (i.e a menos que se declare `public`).

## üïπÔ∏è Control flow.
Control flow se refiere al orden en el cual el programa es ejecutado y el orden que sigue. Este decide que declaraciones, instrucciones o llamadas de funciones son ejecutadas y en qu√© orden, bas√°ndose en decisiones hechas en el momento de ejecuci√≥n. <br/>

Podemos distinguir tres constructores comunes de control flow en Motoko: dichas expresiones son `if else` , `loops` y `switch`.
### If/else
La declaraci√≥n `if` permite al programa tomar decisiones y ejecutar un bloque de c√≥digo espec√≠fico solo si la condici√≥n se cumple. La declaraci√≥n opcional  `else` permite una alternativa si la condici√≥n no se cumple. 
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true
        } else {
            return false
        };
    };
```
En este caso, la condici√≥n `n % 2` ser√° probada en la ejecuci√≥n y dependiendo del valor de `n` devolver√° `true` o `false`.
En algunos casos el bloque `else`puede ser removido sin modificar el comportamiento del c√≥digo.
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true;
        };
        return false;
    };
```
En otros casos, se puede agregar los bloques `else if` para comprobar condiciones adicionales.
```motoko
    func checkNumber(i : Int) : Text {
        if(n < 0) {
            return ("The number is negative.");
        } else if (n == 0) {
            return("The number is zero.");
        } else if (n < 10) {
            return("The number is one digits.");
        } else if (n < 100) {
            return("The number is two digits.");
        } else {
            return ("The number is three or more digits.");
        }
    };
```
Debes recordar que la declaraci√≥n `else if` es usada despu√©s de la declaraci√≥n `if` inicial  para comprobar condiciones adicionales, y solo el bloque de c√≥digo relacionado con la primera condici√≥n que devuelva true ser√° ejecutado.
### Loops (bucles)
Loops permite la ejecuci√≥n de un c√≥digo hasta que cierta condici√≥n se cumpla. Se pueden encontrar distintos tipos de bucles ,como bucles`for`y bucles `while`:
- Bucles `for` en Motoko usan un iterador del tipo `Iter`. Discutiremos sobre el tipo `Iter` m√°s Adelante en otro cap√≠tulo, pero para resumir, los objetos `Iter` facilitan el recorrer un bucle y la colecci√≥n de datos.
```motoko
var count : Nat = 0;
for (x in Iter.range(0, 10)) {
    count += 1;
};
```
En este ejemplo, `Iter.range(0, 10)` recorre todos los n√∫meros naturales entre 0 y 10, incluyendo ambos n√∫meros.

Alternativamente, puedes usar los bucles `while`, los cuales se ejecutan siempre y cuando una condici√≥n se cumpla y devuelva true.

```motoko
var count : Nat = 0;
while (count < 10) {
    count += 1;
};
```
En este caso, el bucle se seguir√° ejecutando hasta que la variable `count` siga siendo menor que 10.
### Switch/case
La expresi√≥n `switch` en Motoko es un constructor que controla el flujo del c√≥digo bas√°ndose en el  input. Comienza con la palabra clave `switch` , seguido del input entre par√©ntesis `()`, y un bloque de c√≥digo encerrado entre llaves `{}`.
```motoko
let x = 3;
switch(x) {
    //
};
```
Dentro de este bloque de c√≥digo, la palabra clave `case` es usada para definir patrones y expresiones encerradas dentro de llaves `{}`. El input es comparado a cada valor especificado en cada caso, y si se encuentra una coincidencia, la expresi√≥n correspondiente a cada  `case` es ejecutada.
```motoko
let x = 3;
switch(x) {
    case(0) {
        // This corresponds to the case x == 0
        return ("x is equal to 0");
    };
    case (1) {
        // This corresponds to the case x == 1
        return ("x is equal to 1");
    };
    case (2) {
        // This corresponds to the case x == 2
        return ("x is equal to 2");
    };
    case (_) {
        // This corresponds to all other cases
        return ("x is above 2");
    };
};
```
En Motoko, es obligado incluir una declaraci√≥n  `case(_)` para cada posible valor del input en una expresi√≥n `switch`. Es por eso que case(`_`) a veces es usado como un catch-all case para manejar cualquier valor de un input que no coincide con ning√∫n otro case. El s√≠mbolo de raya baja (`_`) es un comod√≠n que coincide con cualquier valor, por lo que `case(_)` coincidir√° con cualquier valor del input.

La expresi√≥n `switch/case` se usa mejor con variantes.

```motoko
type Day = {
    #Monday;
    #Tuesday;
    #Wednesday;
    #Thursday;
    #Friday;
    #Saturday;
    #Sunday;
};
let day = #Monday;

switch(day) {
    case(#Monday){
        return ("Today is Monday");
    };
    case(#Tuesday){
        return ("Today is Tuesday");
    };
    case(#Wednesday){
        return ("Today is Wednesday");
    };
    case(#Thursday){
        return ("Today is Thursday");
    };
    case(#Friday){
        return ("Today is Friday");
    };
    case(#Saturday){
        return ("Today is Saturday");
    };
    case(#Sunday){
        return ("Enjoy your Sunday");
    };
};
```
En este ejemplo, definimos una variante de tipo `Day`, declarando una variable `day` con dicho tipo , y despu√©s esta ser√° usada como nuestro input para la expresi√≥n `switch`. La expresi√≥n switch es un poderoso controlador de flujo que permite la coincidencia de patrones, proporcionando una concisa y le√≠ble manera de manejar m√∫ltiples casos basados en el valor del input.
