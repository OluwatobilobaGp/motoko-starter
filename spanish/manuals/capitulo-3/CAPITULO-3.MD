# Chapter 3:  Tipos primitivos en Motoko.
Los tipos primitivos son tipos de datos fundamentales que no est√°n compuestos de m√°s tipos fundamentales. <br/>

Los tipos de datos primitivos son todos los tipos de datos que no necesitan ser importados antes de ser usados en type annotation.
<p align="center"> <img src="./assets/motoko_primitives_types.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Unos cuantos tipos de datos primitivos en Motoko</p>

## üî¢ Nat
`Nat` es usado para los n√∫meros naturales **unbounded** (1,2,3,4,...‚ôæÔ∏è). Por defecto todos los n√∫meros enteros positivos son encapsulados como `Nat`.
```motoko
let n : Nat = 1;
```
Es lo mismo que 

```motoko
let n = 1; // Ser√° reconocido como tipo Nat autom√°ticamente
```
**Unbounded** significa que el valor de tipo `Nat` nunca [desbordara](https://www.youtube.com/watch?v=WN8i5cwjkSE). La representaci√≥n en la memoria aumenta para albergar cualquier n√∫mero finito. Motoko Tambi√©n tiene el concepto de n√∫mero naturales **bounded**  (`Nat8`, `Nat16`, `Nat32`, `Nat64`) de los que hablaremos mas adelante. Si intentas asignar un n√∫mero negativo a un `Nat`el programa se parar√°. 

```motoko
let n : Nat = -1;
```
Esta l√≠nea devolver√° un error: `literal of type Int does not have expected type Nat`.

`Nat` soporta operaciones usuales:
- Suma: puedes sumar dos n√∫meros usando el operador `+`

```motoko
let a : Nat = 1 + 1;    // 2
```
- Resta: puedes restar dos n√∫meros usando el operador `-`
```motoko
let a : Nat = 10 - 2;   // 8
```
> S√© cuidadoso con la resta. `Nat`solo es aplicable para n√∫meros positivos. Si el resultado de la resta es menor de cero, este no encaja. El valor no ser√° m√°s de tipo `Nat` y esto puede causar un problema si tu programa espera un valor de tipo `Nat`. 

-Multiplicaci√≥n: puedes multiplicar dos n√∫meros usando el operador `*`
```motoko
let a : Nat = 10 * 10;  // 100
```
- Divisi√≥n y m√≥dulo: para dividir dos n√∫meros, puedes usar el operador de divisi√≥n `/`  y para encontrar el resto de dividir a entre b, puedes usar el operador de modulo `%`
```motoko
let a : Nat = 10 / 2;   // 5
let b : Nat = 3 % 2;    // 1
```
## ‚ûñ Int.
Los Integers representan n√∫meros enteros que pueden ser positivos o negativos. Las mismas operaciones matem√°ticas que vimos anteriormente (suma, resta, multiplicaci√≥n, divisi√≥n y m√≥dulo) pueden ser realizadas con ambos `Int` y `Nat`.

```motoko
let i : Int = -3; 
let j : Int = 5;
```

> Desde que `Int` incluye n√∫meros enteros positivos y negativos incluye todos los valores de tipo `Nat`. Decimos que `Nat` es un subtipo de `√ånt`.

`√ånt`es tambi√©n un tipo ilimitado y tambi√©n tiene equivalentes limitadas que veremos m√°s adelante (`Int8`, `Int16`, `Int32`, `Int64`).
## üö¶ Bool.
Un `Bool` puede ser `true` o `false`. `Bool` significa boolean y este tipo de dato solo contiene dos valores.
```motoko
let light_on : Bool = true;
let door_open : Bool = false;
````

Booleans pueden ser usados y combinados con operadores l√≥gicos:

- `and`
```motoko
let result = false and false;   //false
```
```motoko
let result = true and false;    //false
```
```motoko
let result = false and true;    //false
```
```motoko
let result = true and true;     //true
```
- `or`
```motoko
let result = false or false;   //false
```
```motoko
let result = true or false;    //true
```
```motoko
let result = false or true;    //true
```
```motoko
let result = true or true;     //true
```
- `not`

```motoko
let result = not true;      //false
```
```motoko
let result = not false;     //true
```

`Nat` e `Int` soportan operadores de comparaci√≥n, los cuales comparan dos integers y devuelven un `Bool`: 
- El operador `==` (igualdad) indica si dos valores son iguales.
- El operador `!=` (no igual) indica si dos valores son diferentes.
- Los operadores `<` (menor que) y `>` (mayor que).
- Los operadores `<=` (menor o igual que) y `>=` (mayor o igual que).

```motoko
3 < 5   // true
1 >= 1  // true
1 != 1  // false
2 == 10/5   // true
```
> El operador `==` es muy distinto del operador '=`.  El primero probar√° si dos valores son iguales mientras que el otro asignar√° un valor a una variable.
## üí¨ Texto
En Motoko, strings pueden ser escritas entre comillas dobles `"`
```motoko
"Hello Motoko Bootcamp!"
```
El tipo para string es `Text`.
```motoko
let welcomePhrase : Text = "Hello Motoko Bootcamp!";
```

Podemos usar el operador de concatenaci√≥n `#` para unir dos `Text` juntos.
```motoko
let firstName : Text = "Motoko";
let surname : Text = "Bootcamp";
let completeName : Text = firstName # surname;
```

Podemos acceder el tama√±o de un `Text`llamando al m√©todo `.size()`.
```motoko
let name : Text = "Motoko";
let size = name.size()  // 6
```
## üî§ Char
Un valor de tipo `Text` en s√≠ est√° compuesto por valores de otro tipo llamado `Char`. Un `Text` es la concatenaci√≥n de m√∫ltiples caracteres. Los caracteres son delimitados por comillas simples `'`
```motoko
let character_1 : Char = 'c';
let character_2 : Char = '8';
let character_3 : Char = '‚àè';
```
`Char` son representados por sus [Unicode code points](https://deliciousbrains.com/how-unicode-works/). Podemos usar el m√≥dulo `Char` desde la librer√≠a base para comprobar el valor unicode. 
```motoko
import Char "mo:base/Char";
import Debug "mo:base/Debug";
actor {
    let a : Char = 'a';
    Debug.print(debug_show(Char.toNat32(a)));   // 97
}
```
Podemos iterar f√°cilmente sobre todos los caracteres de un `Text`, llamando al m√©todo `chars()`. Podemos usar esta iteraci√≥n para crear un bucle `for`.
```motoko
import Debug "mo:base/Debug";
import Char "mo:base/Char";
actor {
    let name : Text = "Motoko";
    for (letter in name.chars()){
        Debug.print(Char.toText(letter));
    };
};
```
> Date cuenta de c√≥mo cada `letter` que iteramos es un `Char` y necesitamos convertirlo de vuelta a `Text`para usar `Debug.print`.

El m√≥dulo `Char` tambi√©n contiene unas cuantas funciones que pueden ser usadas para probar las propiedades de los caracteres:
- `isDigit`
```motoko
Char.isDigit('9');  // true
```
- `isWhitespace`
```motoko
Char.isWhitespace('a'); // false
```
- `isLowercase`
```motoko
Char.isLowercase('c');  //  true
```
- `isUppercase`
```motoko
Char.isUppercase('D');  // true
```
- `isAlphabetic`
```motoko
Char.isAlphabetic('|'); // false
```
## üí• Float.
`Float` son n√∫meros con parte decimal.
```motoko
let pi = 3.14;
let e = 2.71;
```
Si quieres usar `Float`para n√∫meros enteros, necesitas a√±adir la descripci√≥n de tipo de otra forma ser√°n asignadas autom√°ticamente a `√ånt` o `Nat`. 
```motoko
let f : Float = 2;
let n = 2;  // Automatically casted to type Nat
```

`Float`son implementados en 64-bits siguiendo la [ represetacion IEEE 754](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/).Debido al limite de precision, las operaciones pueden resultar en errores numericos.
```motoko
0.1 + 0.1 + 0.1 == 0.3 // => false
```
```motoko
1e16 + 1.0 != 1e16 // => false
```
## üéõÔ∏è Tipos limitados
Motoko proporciona apoyo para los tipos limitados, los cuales son tipos integer con una precisi√≥n fijada. Estos tipos limitados pueden ser √∫tiles por diversas razones:

- Eficiencia de la memoria: Los tipos limitados te permiten saber exactamente cuanta memoria ocupa tus datos.
- Tama√±o exacto: Cuando sabes que una API devuelve un n√∫mero exacto, puedes usar tipos limitados para asegurarte de que el n√∫mero devuelto se representa con exactitud.
- Ejecuci√≥n eficiente: si sabes que tus n√∫meros requieren una aritm√©tica de 64-bit, usar `Nat64` es m√°s eficiente que usar `Nat`.
- Bitwise arithmetic: Los tipos limitados hacen m√°s f√°cil el realizar operaciones de bits como `<<` o `XOR` en datos binarios.

### Nat8, Nat16, Nat32 and Nat64
Hay cuatro tipos naturales soportados por Motoko:`Nat8`, `Nat16`, `Nat32`, y `Nat64`.

El n√∫mero en el nombre del tipo especifica el n√∫mero de bits en la representaci√≥n del tipo. Por ejemplo, `Nat32` representa un n√∫mero natural de 32-bit.

Para declarar una variable limitada, debes especificar expl√≠citamente el tipo para evitar que se le asigne el tipo `Nat autom√°ticamente`:
```motoko
let n : Nat32 = 1;
```
Por el contrario, si tu declaras una variable sin especificar su tipo, se tomar√° por defecto el tipo `Nat`
```motoko
let n = 1; // Will be casted to Nat automatically
```
### Int8, Int16, Int32, y Int64
Motoko tambi√©n soporta tipos integers, incluyendo `Int8`, `Int16`, `Int32`, y `Int64`. Los tipos integers limitados se comportan de forma similar a los tipos naturales limitados, excepto que si soportan n√∫meros negativos. The number in the type name specifies the number of bits in the type representation. For example, `Int32` represents a 32-bit integer:
```motoko
let i : Int32 = -1;
```

## ü§ñ Blob.
`Blob` significa  Binary Large Object (objeto binario largo). El tipo `Blob` representa una secuencia inmutable de bytes: son inmutables, iterables, pero no indexables y puede estar vac√≠o. <br/>

Las secuencias de bytes en ocasiones son representadas como `[Nat8]`, i.e. un array de bytes, pero esta representaci√≥n es menos compacta que `Blob`, tomando 4 bytes f√≠sicos para representar cada byte en la secuencia.
Si deseas manipular Blobs, es recomendado que conviertas `Blobs` a `[var Nat8]` o `Buffer<Nat8>`, usa los datos  y luego vuelve a convertirlos.

## ü´ô Unit type
El √∫ltimo tipo que mencionaremos en este cap√≠tulo es el tipo unit  `()`. Este tipo tambi√©n se conoce como el tipo de la tupla vac√≠a. Es √∫til en varias situaciones, como por ejemplo en funciones que indican que una funci√≥n no devuelve un tipo espec√≠fico.
```motoko
import Debug "mo:base/Debug";
actor {
    public func printMessage(message : Text) : async () {
        Debug.print(message);
        return();
    };
}
```
