# Cap√≠tulo 3: Types primitivos en Motoko
Los tipos primitivos son tipos de datos fundamentales que no est√°n compuestos de tipos m√°s fundamentales. <br/>

Los tipos primitivos son todos los tipos que no necesitan ser importados antes de que se puedan utilizar en la anotaci√≥n de tipos.
<p align="center"> <img src="../../../chapters/chapter-3/assets/motoko_primitives_types.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Algunos tipos primitivos en Motoko</p>

## üî¢ Nat
`Nat` se utiliza para n√∫meros naturales **ilimitados** (1,2,3,4,...‚ôæÔ∏è). Por defecto, todos los n√∫meros enteros positivos se convierten a `Nat`.
```motoko
let n : Nat = 1;
```
Es equivalente a

```motoko
let n = 1; // Will be casted to Nat automatically
```
**Unbounded** significa que el valor del tipo `Nat` nunca [desbordar√°](https://www.youtube.com/watch?v=WN8i5cwjkSE). La representaci√≥n de memoria utilizada crecer√° para acomodar cualquier n√∫mero finito. Motoko tambi√©n tiene el concepto de n√∫meros naturales **acotados** (`Nat8`, `Nat16`, `Nat32`, `Nat64`) que cubriremos m√°s adelante. Si intentas asignar un n√∫mero negativo a un `Nat`, el programa se detendr√°.

```motoko
let n : Nat = -1;
```
Esta l√≠nea devolver√° un error: `literal of type Int does not have expected type Nat`.

`Nat` admite operaciones usuales:
- Adici√≥n: puedes sumar dos n√∫meros utilizando el operador de adici√≥n `+`.

```motoko
let a : Nat = 1 + 1;    // 2
```

- Sustracci√≥n: puedes restar dos n√∫meros utilizando el operador de sustracci√≥n `-`.
```motoko
let a : Nat = 10 - 2;   // 8
```
> Ten cuidado con las restas. `Nat` solo trabaja con n√∫meros positivos. Si el resultado de la resta es menor que cero, no cabr√°. El valor ya no ser√° del tipo `Nat` y eso podr√≠a causar problemas si tu programa est√° esperando un valor del tipo `Nat`.

- Multiplicaci√≥n: puedes multiplicar dos n√∫meros utilizando el operador de multiplicaci√≥n `*`.
```motoko
let a : Nat = 10 * 10;  // 100
```
- Divisi√≥n y m√≥dulo: para dividir dos n√∫meros, puedes utilizar el operador de divisi√≥n `/` y para encontrar el resto de la divisi√≥n de a por b, puedes utilizar el operador de m√≥dulo `%`.
```motoko
let a : Nat = 10 / 2;   // 5
let b : Nat = 3 % 2;    // 1
```
## ‚ûñ Int
Los enteros representan n√∫meros enteros que pueden ser positivos o negativos. Las mismas operaciones matem√°ticas vistas anteriormente (suma, multiplicaci√≥n, resta, divisi√≥n y m√≥dulo) se pueden realizar tanto en `Int` como en `Nat`.

```motoko
let i : Int = -3; 
let j : Int = 5;
```
> Dado que `Int` incluye n√∫meros enteros positivos y negativos, incluye todos los valores del tipo `Nat`. Decimos que `Nat` es un subtipo de `Int`.

`√ånt` tambi√©n es un tipo ilimitado y tiene equivalentes acotados que cubriremos m√°s adelante (`Int8`, `Int16`, `Int32`, `Int64`).
## üö¶ Bool
Un `Bool` es `true` o `false`. `Bool` significa booleano y este tipo de dato solo contiene dos valores.
```motoko
let light_on : Bool = true;
let door_open : Bool = false;
````
Los booleanos se pueden usar y combinar con operadores l√≥gicos:

- `and` (y)
```motoko
let result = false and false;   //false
```
```motoko
let result = true and false;    //false
```
```motoko
let result = false and true;    //false
```
```motoko
let result = true and true;     //true
```
- `or`
```motoko
let result = false or false;   //false
```
```motoko
let result = true or false;    //true
```
```motoko
let result = false or true;    //true
```
```motoko
let result = true or true;     //true
```
- `not`

```motoko
let result = not true;      //false
```
```motoko
let result = not false;     //true
```

`Nat` e `Int` admiten operadores de comparaci√≥n, que comparan dos enteros y devuelven un `Bool`:
- El operador `==` (igualdad) que indica si dos valores son iguales.
- El operador `!=` (diferente) que indica si dos valores son diferentes.
- Los operadores `<` (menor que) y `>` (mayor que).
- Los operadores `<=` (menor o igual que) y `>=` (mayor o igual que).

```motoko
3 < 5   // true
1 >= 1  // true
1 != 1  // false
2 == 10/5   // true
```
> El operador `==` es muy diferente del operador `=`. El primero comprobar√° si dos valores son iguales, mientras que el √∫ltimo asignar√° un valor a una variable.

## üí¨ Texto
En Motoko, las cadenas de texto se pueden escribir rodeadas de comillas dobles `"`
```motoko
"Hello Motoko Bootcamp!"
```
El tipo para una cadena es `Text`.
```motoko
let welcomePhrase : Text = "Hello Motoko Bootcamp!";
```

Podemos usar el operador de concatenaci√≥n `#` para unir dos valores `Text`.
```motoko
let firstName : Text = "Motoko";
let surname : Text = "Bootcamp";
let completeName : Text = firstName # surname;
```

Podemos acceder al tama√±o de un valor `Text` llamando al m√©todo `.size()`.
```motoko
let name : Text = "Motoko";
let size = name.size()  // 6
```
## üî§ Char
Un valor del tipo `Text` est√° compuesto en realidad por valores de otro tipo: `Char`. Un `Text` es la concatenaci√≥n de varios caracteres. Los caracteres se delimitan con comillas simples `'`.
```motoko
let character_1 : Char = 'c';
let character_2 : Char = '8';
let character_3 : Char = '‚àè';
```
`Char` se representan por sus [puntos de c√≥digo Unicode](https://deliciousbrains.com/how-unicode-works/). Podemos usar el m√≥dulo `Char` de la biblioteca Base para verificar el valor Unicode.
```motoko
import Char "mo:base/Char";
import Debug "mo:base/Debug";
actor {
    let a : Char = 'a';
    Debug.print(debug_show(Char.toNat32(a)));   // 97
}
```
`Char` se representan por sus [puntos de c√≥digo Unicode](https://deliciousbrains.com/how-unicode-works/). Podemos usar el m√≥dulo `Char` de la biblioteca Base para verificar el valor Unicode.
```motoko
import Debug "mo:base/Debug";
import Char "mo:base/Char";
actor {
    let name : Text = "Motoko";
    for (letter in name.chars()){
        Debug.print(Char.toText(letter));
    };
};
```
> Observa que cuando iteramos `letter` es un `Char` y necesitamos convertirlo de vuelta a `Text` para usar `Debug.print`.

El m√≥dulo `Char` tambi√©n contiene algunas funciones que se pueden utilizar para probar propiedades de los caracteres:
- `isDigit` (es d√≠gito)
```motoko
Char.isDigit('9');  // true
```
- `isWhitespace`
```motoko
Char.isWhitespace('a'); // false
```
- `isLowercase`
```motoko
Char.isLowercase('c');  //  true
```
- `isUppercase`
```motoko
Char.isUppercase('D');  // true
```
- `isAlphabetic`
```motoko
Char.isAlphabetic('|'); // false
```
## üí• Float.
`Float` son n√∫mero que tienen partes naturales.
```motoko
let pi = 3.14;
let e = 2.71;
```
Si quieres utilizar `Float` para n√∫meros enteros, necesitas agregar un descriptor de type o automaticamente ser√° transformados a `√ånt` o `Nat`. 
```motoko
let f : Float = 2;
let n = 2;  // Automatically casted to type Nat
```

Los `Float` se implementan en 64 bits siguiendo la [representaci√≥n IEEE 754](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/). Debido a la precisi√≥n limitada, las operaciones pueden dar lugar a errores num√©ricos.
```motoko
0.1 + 0.1 + 0.1 == 0.3 // => false
```
```motoko
1e16 + 1.0 != 1e16 // => false
```
## üéõÔ∏è Types acotados
Motoko proporciona soporte para tipos acotados que son tipos de enteros con una precisi√≥n fija. Estos tipos acotados pueden ser √∫tiles por varias razones:

- Eficiencia de memoria: los tipos acotados le permiten saber exactamente cu√°nta memoria ocupar√° sus datos.
- Tama√±o exacto: cuando sabe que una API devuelve un n√∫mero exacto, puede utilizar tipos acotados para asegurarse de que el n√∫mero devuelto se represente con precisi√≥n.
- Eficiencia de ejecuci√≥n: si sabe que sus n√∫meros requieren aritm√©tica de 64 bits, usar `Nat64` es m√°s eficiente que usar `Nat`.
- Aritm√©tica de bits: los tipos acotados facilitan la realizaci√≥n de operaciones de bits como `<<` o `XOR` en datos binarios.

### Nat8, Nat16, Nat32 y Nat64
Hay cuatro tipos naturales admitidos en Motoko: `Nat8`, `Nat16`, `Nat32` y `Nat64`.

El n√∫mero en el nombre del tipo especifica la cantidad de bits en la representaci√≥n del tipo. Por ejemplo, `Nat32` representa un n√∫mero natural de 32 bits.

Para declarar una variable acotada, debe especificar el tipo expl√≠citamente para evitar que se convierta autom√°ticamente en un `Nat` regular:
```motoko
let n : Nat32 = 1;
```
En cambio, si declara una variable sin especificar su tipo, se convertir√° autom√°ticamente en un `Nat` regular.
```motoko
let n = 1; // Will be casted to Nat automatically
```
### Int8, Int16, Int32 y Int64
Motoko tambi√©n admite tipos de enteros, incluidos `Int8`, `Int16`, `Int32` e `Int64`. Los tipos de enteros acotados se comportan de manera similar a los tipos naturales acotados, excepto que admiten valores negativos. El n√∫mero en el nombre del tipo especifica la cantidad de bits en la representaci√≥n del tipo. Por ejemplo, `Int32` representa un entero de 32 bits:
```motoko
let i : Int32 = -1;
```

## ü§ñ Blob.
`Blob` representa un objeto binario grande. El tipo `Blob` representa una secuencia inmutable de bytes: son inmutables, iterables, pero no indexables y pueden estar vac√≠os. <br/>

Las secuencias de bytes tambi√©n se representan a menudo como `[Nat8]`, es decir, una matriz de bytes, pero esta representaci√≥n es actualmente mucho menos compacta que `Blob`, lo que hace que se necesiten 4 bytes f√≠sicos para representar cada byte l√≥gico en la secuencia.
Si desea manipular Blobs, se recomienda convertir `Blobs` a `[var Nat8]` o `Buffer<Nat8>`, hacer la manipulaci√≥n y luego convertirlos de vuelta.

## ü´ô Type unitario
El √∫ltimo tipo que mencionaremos en este cap√≠tulo es el tipo unitario `()`. Este tipo tambi√©n se llama tipo de tupla vac√≠a. Es √∫til en varios lugares, por ejemplo, en funciones para indicar que una funci√≥n no devuelve ning√∫n tipo espec√≠fico.
```motoko
import Debug "mo:base/Debug";
actor {
    public func printMessage(message : Text) : async () {
        Debug.print(message);
        return();
    };
}
```
